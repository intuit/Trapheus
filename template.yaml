AWSTemplateFormatVersion: '2010-09-09'
Transform: AWS::Serverless-2016-10-31
Description: >
  Trapheus

  Restoration of a RDS instance or cluster from a snapshot using a Lambda state machine.

Globals:
  Function:
    Runtime: python3.11
    Timeout: 900
    Environment:
      Variables:
        Region:
          Fn::Sub: ${AWS::Region}

Parameters:
  ProjectName:
    Default: "trapheus"
    Description: The name of the artifacts bucket
    Type: String
  vpcId:
    Type: AWS::EC2::VPC::Id
    Description: choose the VPC under which all lambdas will be configured
  Subnets:
    Type: String
    Description: The comma separated list of SubnetIds in your Virtual Private Cloud (VPC)
  SenderEmail:
    Type: String
    Description: sender email account for failure alert
  RecipientEmail:
    Type: String
    Description: comma separated list of recipient email ids for failure alerts
  SlackWebhookUrls:
    Type: String
    Default : "https://hooks.slack.com"
    Description: comma seperated list of slack webhooks for failure alerts
  UseVPCAndSubnets:
    Type: String
    Description: Whether to use VPC and Subnets in Lambda-s.
    Default : "true"

  # Route 53
  ConfigureDns:
    Description: Configure Route 53 DNS Alias for RDS? Be sure a matching record doesn't already exist.
    Type: String
    Default: 'false'
    AllowedValues:
      - 'true'
      - 'false'
  Cname:
    Description: "(Skip if Not Configuring Route 53) DNS Record to Update for the RDS Instance."
    Type: String
    Default: db.domain.com
  R53HostedZoneName:
    Description: "(Skip if Not Configuring Route 53) Hosted DNS Name."
    Type: String
    Default: domain.com

Conditions:
  UseVPCAndSubnetsCondition: !Equals [ !Ref UseVPCAndSubnets, "true" ]
  ConfigureRoute53: !Equals [ !Ref ConfigureDns, 'true' ]

Resources:
  LambdaExecutionRole:
    Type: "AWS::IAM::Role"
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: "sts:AssumeRole"
          - Effect: Allow
            Principal:
              Service: export.rds.amazonaws.com
            Action: "sts:AssumeRole"
      Path: "/"
      Policies:
        - PolicyName: SnapshotExportPolicy
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Resource: "*"
                Action:
                  - iam:PassRole
              - Effect: Allow
                Resource:
                  - !Sub "arn:aws:s3:::rds-snapshots-${AWS::AccountId}"
                  - !Sub "arn:aws:s3:::rds-snapshots-${AWS::AccountId}/*"
                Action:
                  - s3:PutObject
                  - s3:DeleteObject
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AmazonRDSFullAccess
        - arn:aws:iam::aws:policy/CloudWatchLogsFullAccess
        - arn:aws:iam::aws:policy/AmazonS3ReadOnlyAccess
        - arn:aws:iam::aws:policy/AmazonSESFullAccess
        - arn:aws:iam::aws:policy/AmazonVPCReadOnlyAccess
        - arn:aws:iam::aws:policy/service-role/AWSLambdaVPCAccessExecutionRole
        - arn:aws:iam::aws:policy/AWSStepFunctionsReadOnlyAccess
        - arn:aws:iam::aws:policy/AWSLambdaExecute
        - arn:aws:iam::aws:policy/service-role/AmazonSSMAutomationRole
      Tags:
        AppComponent: "iamrole"

  RDSAutomationExecutionRole:
    Type: "AWS::IAM::Role"
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: ssm.amazonaws.com
            Action: "sts:AssumeRole"
      Path: "/"
      Policies:
        - PolicyName: kms-ssm-automation-policy
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Resource: "*"
                Action:
                  - "iam:CreateServiceLinkedRole"
                  - "kms:EnableKey"
                  - "kms:Decrypt"
                  - "kms:ListKeyPolicies"
                  - "kms:PutKeyPolicy"
                  - "kms:GetKeyPolicy"
                  - "kms:ListResourceTags"
                  - "kms:DisableKey"
                  - "kms:ReEncryptFrom"
                  - "kms:ListGrants"
                  - "kms:ListKeys"
                  - "kms:TagResource"
                  - "kms:Encrypt"
                  - "kms:ScheduleKeyDeletion"
                  - "kms:CreateAlias"
                  - "kms:ReEncryptTo"
                  - "kms:DescribeKey"
                  - "kms:CreateKey"
                  - "kms:CreateGrant"
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AmazonRDSFullAccess
        - arn:aws:iam::aws:policy/service-role/AmazonSSMAutomationRole
      Tags:
        - Key: "AppComponent"
          Value: "trapheus:iamrole"

  RecordSet:
    Condition: ConfigureRoute53
    Type: AWS::Route53::RecordSet
    Properties:
      HostedZoneName: !Join [ "", [ !Ref R53HostedZoneName, "." ] ]
      Comment: CNAME Redirect to the RDS
      Name: !Join [ "", [ !Ref Cname, "." ] ]
      Type: CNAME
      TTL: 300

  StatesExecutionRole:
    Type: "AWS::IAM::Role"
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: "Allow"
            Principal:
              Service:
                - !Sub states.${AWS::Region}.amazonaws.com
            Action: "sts:AssumeRole"
      Path: "/"
      Policies:
        - PolicyName: StatesExecutionPolicy
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - "lambda:InvokeFunction"
                Resource: "*"
      Tags:
        - Key: "AppComponent"
          Value: "trapheus:iamrole"

  CWEventStatesExecutionRole:
    Type: "AWS::IAM::Role"
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: "Allow"
            Principal:
              Service:
                - !Sub events.amazonaws.com
            Action: "sts:AssumeRole"
      Policies:
        - PolicyName: CWEventStatesExecutionPolicy
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - "states:StartExecution"
                Resource: !GetAtt DBRestoreStateMachine.Arn
      Tags:
        - Key: "AppComponent"
          Value: "trapheus:iamrole"

  RestoreDBFromSharedSnapshotSSMDocument:
    Type: 'AWS::SSM::Document'
    Properties:
      Name: Trapheus-RestoreDatabaseFromSharedSnapshot
      DocumentFormat: YAML
      DocumentType: Automation
      Content:
        schemaVersion: '0.3'
        assumeRole: '{{ AutomationAssumeRole }}'
        parameters:
          SharedSnapshotARN:
            type: String
          NewSnapshotIdentifier:
            type: String
          AutomationAssumeRole:
            type: String
            default: ''
          NewDatabaseIdentifier:
            type: String
          TargetVPCId:
            type: String
            description: vpc id that defines the virtual networking environment for the new restored DB instance.
            default: ''
        mainSteps:
          - name: DescribeSharedSnapshot
            action: 'aws:executeAwsApi'
            inputs:
              Service: rds
              Api: DescribeDBSnapshots
              DBSnapshotIdentifier: '{{ SharedSnapshotARN }}'
              IncludeShared: true
            outputs:
              - Name: SharedSnapshotKmsKeyId
                Selector: '$.DBSnapshots[0].KmsKeyId'
                Type: String
            nextStep: CreateManualCopyOfSharedSnapshot
          - name: CreateManualCopyOfSharedSnapshot
            action: 'aws:executeAwsApi'
            outputs:
              - Name: DBSnapshotIdentifier
                Selector: $.DBSnapshot.DBSnapshotIdentifier
                Type: String
            inputs:
              Service: rds
              Api: CopyDBSnapshot
              SourceDBSnapshotIdentifier: '{{ SharedSnapshotARN }}'
              TargetDBSnapshotIdentifier: '{{ NewSnapshotIdentifier }}'
              KmsKeyId: '{{ DescribeSharedSnapshot.SharedSnapshotKmsKeyId }}'
            isEnd: false
            onFailure: Abort
            nextStep: WaitForAvailableStateOfNewManualSnapshot
          - name: WaitForAvailableStateOfNewManualSnapshot
            action: 'aws:waitForAwsResourceProperty'
            inputs:
              Service: rds
              Api: DescribeDBSnapshots
              PropertySelector: '$.DBSnapshots[0].Status'
              DesiredValues:
                - available
              DBSnapshotIdentifier: '{{ CreateManualCopyOfSharedSnapshot.DBSnapshotIdentifier }}'
            maxAttempts: 10
            timeoutSeconds: 600
            nextStep: RestoreDBInstanceFromSnapshot
          - name: RestoreDBInstanceFromSnapshot
            action: 'aws:executeAwsApi'
            inputs:
              Service: rds
              Api: RestoreDBInstanceFromDBSnapshot
              DBInstanceIdentifier: '{{ NewDatabaseIdentifier }}'
              DBSnapshotIdentifier: '{{ CreateManualCopyOfSharedSnapshot.DBSnapshotIdentifier }}'
              DBSubnetGroupName: 'default-{{ TargetVPCId }}'
            outputs:
              - Name: NewDBInstanceIdentifier
                Selector: $.DBInstance.DBInstanceIdentifier
                Type: String
            isEnd: false
            onFailure: Abort
            nextStep: WaitForAvailableStateOfRestoredDBInstance
          - name: WaitForAvailableStateOfRestoredDBInstance
            action: 'aws:waitForAwsResourceProperty'
            inputs:
              Service: rds
              Api: DescribeDBInstances
              PropertySelector: '$.DBInstances[0].DBInstanceStatus'
              DesiredValues:
                - available
              DBInstanceIdentifier: '{{ NewDatabaseIdentifier }}'
            maxAttempts: 20
            timeoutSeconds: 1000
            isEnd: true

  LambdaSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Condition: UseVPCAndSubnetsCondition
    Properties:
      GroupDescription: security group added to VPC config of every lambda used
      GroupName: my-sg
      VpcId: !Ref vpcId
      Tags:
        - Key: "AppComponent"
          Value: "trapheus:securityGroup"

  CommonLambdaLayer:
    Type: AWS::Serverless::LayerVersion
    Properties:
      LayerName: lambda-utility
      Description: Dependencies on util methods used in lambdas of the state machine
      ContentUri: src/common/common.zip
      CompatibleRuntimes:
        - python3.11
        - python3.10
        - python3.9
        - python3.8
        - python3.7
        - python3.6
      LicenseInfo: 'MIT'

  ShareSnapshotLambdaFunction:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: "lambda_share_rds_snapshot_cross_account"
      Description: Lambda function required to share rds snapshot to target aws account.
      Role: !GetAtt LambdaExecutionRole.Arn
      Runtime: python3.11
      CodeUri: src/shareSnapshot/
      Handler: share_rds_snapshot_across_accounts.lambda_share_rds_snapshot_cross_account
      MemorySize: 128
      Layers:
        - !Ref CommonLambdaLayer
      Timeout: 900
      Architectures:
        - arm64  # Specify arm64 for Graviton architecture
      Environment:
        Variables:
          SHARE_SNAPSHOT_TASK_ROLE: !GetAtt RDSAutomationExecutionRole.Arn
      VpcConfig:
        !If [ UseVPCAndSubnetsCondition, {
          SecurityGroupIds: !Split [ "," , !GetAtt LambdaSecurityGroup.GroupId ] ,
          SubnetIds: !Split [ "," , !Ref Subnets ]
        } , !Ref "AWS::NoValue" ]

  RestoreRDSInTargetAccountsAndRegionsLambdaFunction:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: "lambda_restore_rds_target_account"
      Description: Lambda function required to restore db in target aws accounts and regions.
      Role: !GetAtt LambdaExecutionRole.Arn
      Runtime: python3.11
      CodeUri: src/restore/
      Handler: cross_account_db_restore.lambda_restore_rds_target_account
      MemorySize: 128
      Layers:
        - !Ref CommonLambdaLayer
      Timeout: 900
      Architectures:
        - arm64  # Specify arm64 for Graviton architecture
      VpcConfig:
        !If [ UseVPCAndSubnetsCondition, {
          SecurityGroupIds: !Split [ "," , !GetAtt LambdaSecurityGroup.GroupId ] ,
          SubnetIds: !Split [ "," , !Ref Subnets ]
        } , !Ref "AWS::NoValue" ]

  RenameLambdaFunction:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: "lambda-function-rename-dbinstance"
      Description: Lambda functions required to execute rename of a database instance.
      Role: !GetAtt LambdaExecutionRole.Arn
      Runtime: python3.11
      CodeUri: src/rename/
      Handler: rename_function.lambda_rename_dbinstance
      MemorySize: 128
      Layers:
        - !Ref CommonLambdaLayer
      Timeout: 900
      Architectures:
        - arm64  # Specify arm64 for Graviton architecture
      VpcConfig:
        !If [UseVPCAndSubnetsCondition, {
          SecurityGroupIds: !Split [ "," , !GetAtt LambdaSecurityGroup.GroupId ] ,
          SubnetIds: !Split [ "," , !Ref Subnets ]
        } , !Ref "AWS::NoValue"  ]
      Tags:
        AppComponent: "trapheus:Lambda"
        AppFunction: "trapheus:RenameDBInstance"

  DbInstanceStatusLambdaFunction:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: "lambda-function-get-dbinstance-status-sf"
      Description: Lambda function which provides information on status of db instance post any operation.
      Role: !GetAtt LambdaExecutionRole.Arn
      Runtime: python3.11
      CodeUri: src/checkstatus/
      Handler: get_dbstatus_function.lambda_get_dbinstance_status
      MemorySize: 128
      Layers:
        - !Ref CommonLambdaLayer
      Timeout: 900
      Architectures:
        - arm64  # Specify arm64 for Graviton architecture
      VpcConfig:
        !If [UseVPCAndSubnetsCondition, {
          SecurityGroupIds: !Split [ "," , !GetAtt LambdaSecurityGroup.GroupId ] ,
          SubnetIds: !Split [ "," , !Ref Subnets ]
        } , !Ref "AWS::NoValue"  ]
      Tags:
        AppComponent: "trapheus:Lambda"
        AppFunction: "trapheus:DBInstanceStatus"

  DBRestoreLambdaFunction:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: "lambda-function-restore-dbinstance-sf"
      Description: Lambda functions required to execute database restore.
      Role: !GetAtt LambdaExecutionRole.Arn
      Runtime: python3.11
      CodeUri: src/restore/
      Handler: restore_function.lambda_restore_dbinstance
      MemorySize: 128
      Layers:
        - !Ref CommonLambdaLayer
      Timeout: 900
      Architectures:
        - arm64  # Specify arm64 for Graviton architecture
      VpcConfig:
        !If [UseVPCAndSubnetsCondition, {
          SecurityGroupIds: !Split [ "," , !GetAtt LambdaSecurityGroup.GroupId ] ,
          SubnetIds: !Split [ "," , !Ref Subnets ]
        } , !Ref "AWS::NoValue"  ]
      Tags:
        AppComponent: "trapheus:Lambda"
        AppFunction: "trapheus:DBInstanceRestore"

  DeleteInstanceLambdaFunction:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: "lambda-function-delete-dbinstance-sf"
      Description: Lambda functions required to execute database instance deletion.
      Role: !GetAtt LambdaExecutionRole.Arn
      Runtime: python3.11
      CodeUri: src/delete/
      Handler: delete_function.lambda_delete_dbinstance
      MemorySize: 128
      Layers:
        - !Ref CommonLambdaLayer
      Timeout: 900
      Architectures:
        - arm64  # Specify arm64 for Graviton architecture
      VpcConfig:
        !If [UseVPCAndSubnetsCondition, {
          SecurityGroupIds: !Split [ "," , !GetAtt LambdaSecurityGroup.GroupId ] ,
          SubnetIds: !Split [ "," , !Ref Subnets ]
        } , !Ref "AWS::NoValue"  ]
      Tags:
        AppComponent: "trapheus:Lambda"
        AppFunction: "trapheus:DeleteDBInstance"

  DBSnapshotLambdaFunction:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: "lambda-function-dbsnapshot-sf"
      Description: Lambda functions required to take snapshot of a database instance.
      Role: !GetAtt LambdaExecutionRole.Arn
      Runtime: python3.11
      CodeUri: src/snapshot/
      Handler: snapshot_function.lambda_create_dbinstance_snapshot
      MemorySize: 128
      Layers:
        - !Ref CommonLambdaLayer
      Timeout: 900
      Architectures:
        - arm64  # Specify arm64 for Graviton architecture
      VpcConfig:
        !If [UseVPCAndSubnetsCondition, {
          SecurityGroupIds: !Split [ "," , !GetAtt LambdaSecurityGroup.GroupId ] ,
          SubnetIds: !Split [ "," , !Ref Subnets ]
        } , !Ref "AWS::NoValue"  ]
      Tags:
        AppComponent: "trapheus:Lambda"
        AppFunction: "trapheus:DBSnapshot"

  EmailAlertLambdaFunction:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: "lambda-function-send-emailalert-sf"
      Description: Lambda functions required to enable alerts in case of any failure of state machine.
      Role: !GetAtt LambdaExecutionRole.Arn
      Runtime: python3.11
      CodeUri: src/emailalert/
      Handler: email_function.lambda_handler
      MemorySize: 128
      Layers:
        - !Ref CommonLambdaLayer
      Timeout: 900
      Architectures:
        - arm64  # Specify arm64 for Graviton architecture
      VpcConfig:
        !If [UseVPCAndSubnetsCondition, {
          SecurityGroupIds: !Split [ "," , !GetAtt LambdaSecurityGroup.GroupId ] ,
          SubnetIds: !Split [ "," , !Ref Subnets ]
        } , !Ref "AWS::NoValue"  ]
      Environment:
        Variables:
          SenderEmail:
            Fn::Sub: ${SenderEmail}
          RecipientEmail:
            Fn::Sub: ${RecipientEmail}
      Tags:
        AppComponent: "trapheus:Lambda"
        AppFunction: "trapheus:EmailAlerting"

  SlackAlertLambdaFunction:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: "lambda-function-send-slackalert-sf"
      Description: Lambda functions required to enable slack alerts in case of any failure of state machine.
      Role: !GetAtt LambdaExecutionRole.Arn
      Runtime: python3.11
      CodeUri: src/slacknotification/
      Handler: slack_notification.lambda_handler
      MemorySize: 128
      Layers:
        - !Ref CommonLambdaLayer
      Timeout: 900
      Architectures:
        - arm64  # Specify arm64 for Graviton architecture
      VpcConfig:
        !If [UseVPCAndSubnetsCondition, {
          SecurityGroupIds: !Split [ "," , !GetAtt LambdaSecurityGroup.GroupId ] ,
          SubnetIds: !Split [ "," , !Ref Subnets ]
        } , !Ref "AWS::NoValue"  ]
      Environment:
        Variables:
          SLACK_WEBHOOK:
            Fn::Sub: ${SlackWebhookUrls}
      Tags:
        AppComponent: "trapheus:Lambda"
        AppFunction: "trapheus:SlackAlerting"

  ClusterRenameLambdaFunction:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: "lambda-function-dbcluster-rename-sf"
      Description: Lambda functions required to execute database cluster rename.
      Role: !GetAtt LambdaExecutionRole.Arn
      Runtime: python3.11
      CodeUri: src/rename/
      Handler: cluster_rename_function.lambda_rename_dbcluster
      MemorySize: 128
      Layers:
        - !Ref CommonLambdaLayer
      Timeout: 900
      Architectures:
        - arm64  # Specify arm64 for Graviton architecture
      VpcConfig:
        !If [UseVPCAndSubnetsCondition, {
          SecurityGroupIds: !Split [ "," , !GetAtt LambdaSecurityGroup.GroupId ] ,
          SubnetIds: !Split [ "," , !Ref Subnets ]
        } , !Ref "AWS::NoValue"  ]
      Tags:
        AppComponent: "trapheus:Lambda"
        AppFunction: "trapheus:DBClusterRename"

  ClusterRestoreLambdaFunction:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: "lambda-function-dbcluster-restore-sf"
      Description: Lambda functions required to execute database cluster restore.
      Role: !GetAtt LambdaExecutionRole.Arn
      Runtime: python3.11
      CodeUri: src/restore/
      Handler: cluster_restore_function.lambda_restore_dbcluster
      MemorySize: 128
      Layers:
        - !Ref CommonLambdaLayer
      Timeout: 900
      Architectures:
        - arm64  # Specify arm64 for Graviton architecture
      VpcConfig:
        !If [UseVPCAndSubnetsCondition, {
          SecurityGroupIds: !Split [ "," , !GetAtt LambdaSecurityGroup.GroupId ] ,
          SubnetIds: !Split [ "," , !Ref Subnets ]
        } , !Ref "AWS::NoValue"  ]
      Tags:
        AppComponent: "trapheus:Lambda"
        AppFunction: "trapheus:DBClusterRestore"

  ClusterStatusLambdaFunction:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: "lambda-function-dbcluster-status-sf"
      Description: Lambda function which provides information on status of db cluster post any operation.
      Role: !GetAtt LambdaExecutionRole.Arn
      Runtime: python3.11
      CodeUri: src/checkstatus/
      Handler: get_dbcluster_status_function.lambda_get_cluster_status
      MemorySize: 128
      Layers:
        - !Ref CommonLambdaLayer
      Timeout: 900
      Architectures:
        - arm64  # Specify arm64 for Graviton architecture
      VpcConfig:
        !If [UseVPCAndSubnetsCondition, {
          SecurityGroupIds: !Split [ "," , !GetAtt LambdaSecurityGroup.GroupId ] ,
          SubnetIds: !Split [ "," , !Ref Subnets ]
        } , !Ref "AWS::NoValue"  ]
      Tags:
        AppComponent: "trapheus:Lambda"
        AppFunction: "trapheus:DBClusterStatus"

  ClusterDeleteLambdaFunction:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: "lambda-function-dbcluster-delete-sf"
      Description: Lambda functions required to execute deletion of database cluster.
      Role: !GetAtt LambdaExecutionRole.Arn
      Runtime: python3.11
      CodeUri: src/delete/
      Handler: cluster_delete_function.lambda_delete_dbcluster
      MemorySize: 128
      Layers:
        - !Ref CommonLambdaLayer
      Timeout: 900
      Architectures:
        - arm64  # Specify arm64 for Graviton architecture
      VpcConfig:
        !If [UseVPCAndSubnetsCondition, {
          SecurityGroupIds: !Split [ "," , !GetAtt LambdaSecurityGroup.GroupId ] ,
          SubnetIds: !Split [ "," , !Ref Subnets ]
        } , !Ref "AWS::NoValue"  ]
      Tags:
        AppComponent: "trapheus:Lambda"
        AppFunction: "trapheus:DBClusterDelete"

  ClusterSnapshotLambdaFunction:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: "lambda-function-dbcluster-snapshot-sf"
      Description: Lambda functions required to take snapshot of database cluster.
      Role: !GetAtt LambdaExecutionRole.Arn
      Runtime: python3.11
      CodeUri: src/snapshot/
      Handler: cluster_snapshot_function.lambda_create_cluster_snapshot
      MemorySize: 128
      Layers:
        - !Ref CommonLambdaLayer
      Timeout: 900
      Architectures:
        - arm64  # Specify arm64 for Graviton architecture
      VpcConfig:
        !If [UseVPCAndSubnetsCondition, {
          SecurityGroupIds: !Split [ "," , !GetAtt LambdaSecurityGroup.GroupId ] ,
          SubnetIds: !Split [ "," , !Ref Subnets ]
        } , !Ref "AWS::NoValue"  ]
      Tags:
        AppComponent: "trapheus:Lambda"
        AppFunction: "trapheus:DBClusterSnapshot"
        
  SnapshotExportKmsKey:
    Type: AWS::KMS::Key
    Properties:
      Description: Symmetric CMK to export snapshot to s3
      KeyPolicy:
        Version: '2012-10-17'
        Id: snapshot-export-key
        Statement:
          - Sid: Enable IAM User Permissions
            Effect: Allow
            Principal:
              AWS: !Sub 'arn:aws:iam::${AWS::AccountId}:root'
            Action: kms:*
            Resource: '*'
          - Sid: Allow administration of the key
            Effect: Allow
            Principal:
              AWS: !GetAtt LambdaExecutionRole.Arn
            Action:
              - kms:Create*
              - kms:Describe*
              - kms:Enable*
              - kms:List*
              - kms:Put*
              - kms:Update*
              - kms:Revoke*
              - kms:Disable*
              - kms:Get*
              - kms:Delete*
              - kms:ScheduleKeyDeletion
              - kms:CancelKeyDeletion
              - kms:TagResource
              - kms:UntagResource
            Resource: '*'
      Tags:
        - Key: "AppComponent"
          Value: "trapheus:CMK"
        - Key: "AppFunction"
          Value: "trapheus:export-snapshot-to-s3"

  SnapshotsBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Sub 'rds-snapshots-${AWS::AccountId}'
      Tags:
        - Key: "AppComponent"
          Value: "trapheus:s3"
        - Key: "AppFunction"
          Value: "trapheus:rds-snapshots-s3"

  SnapshotExportLambdaFunction:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: !Sub ${ProjectName}-snapshot-export-sf
      Description: Lambda functions required to start export task of RDS snapshot to s3.
      Role: !GetAtt LambdaExecutionRole.Arn
      Runtime: python3.11
      CodeUri: src/export/
      Handler: export_snapshot_s3_function.lambda_export_rds_snapshot_to_s3
      MemorySize: 128
      Layers:
        - !Ref CommonLambdaLayer
      Timeout: 900
      Architectures:
        - arm64  # Specify arm64 for Graviton architecture
      Environment:
        Variables:
          SNAPSHOT_EXPORT_TASK_ROLE: !GetAtt LambdaExecutionRole.Arn
          SNAPSHOT_EXPORT_TASK_KEY: !Ref SnapshotExportKmsKey
      VpcConfig:
        SecurityGroupIds: !Split [ "," , !GetAtt LambdaSecurityGroup.GroupId ]
        SubnetIds: !Split [ "," , !Ref Subnets ]
      Tags:
        AppComponent: "trapheus:Lambda"
        AppFunction: "trapheus:DBExportSnapshots"

  ClusterSnapshotExportLambdaFunction:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: !Sub ${ProjectName}-cluster-snapshot-export-sf
      Description: Lambda functions required to start export task of RDS snapshot to s3.
      Role: !GetAtt LambdaExecutionRole.Arn
      Runtime: python3.11
      CodeUri: src/export/
      Handler: export_cluster_snapshot_s3_function.lambda_export_rds_cluster_snapshot_to_s3
      MemorySize: 128
      Layers:
        - !Ref CommonLambdaLayer
      Timeout: 900
      Architectures:
        - arm64  # Specify arm64 for Graviton architecture
      Environment:
        Variables:
          SNAPSHOT_EXPORT_TASK_ROLE: !GetAtt LambdaExecutionRole.Arn
          SNAPSHOT_EXPORT_TASK_KEY: !Ref SnapshotExportKmsKey
      VpcConfig:
        SecurityGroupIds: !Split [ "," , !GetAtt LambdaSecurityGroup.GroupId ]
        SubnetIds: !Split [ "," , !Ref Subnets ]
      Tags:
        AppComponent: "trapheus:Lambda"
        AppFunction: "trapheus:ClusterExportSnapshots"

  DBRestoreStateMachine:
    Type: AWS::StepFunctions::StateMachine
    Properties:
      DefinitionString:
        !Sub
        - |-
          {
            "StartAt": "IsTaskRestoreInTargetAccountsAndRegions",
            "States": {
              "IsTaskRestoreInTargetAccountsAndRegions": {
                "Type": "Choice",
                  "Choices": [{
                    "Variable": "$.task",
                    "StringEquals": "restore_rds_in_target_accounts",
                    "Next": "ShareRDSSnapshot"
                  }],
                  "Default": "ShouldRestoreClusterOrInstance"
              },
              "ShareRDSSnapshot": {
                "Type": "Task",
                "Resource": "${ShareSnapshotLambdaArn}",
                "Next": "RestoreRDSInTargetAccountAndRegion",
                "ResultPath": "$.output",
                "Retry": [{
                  "ErrorEquals": ["AutomationExecutionLimitExceededException"],
                  "IntervalSeconds": 10,
                  "MaxAttempts": 5,
                  "BackoffRate": 2.0
                 }],
                "Catch": [
                  {
                    "ErrorEquals": [ "States.ALL" ],
                    "Next": "FailedState"
                  }
                ]
              },
              "RestoreRDSInTargetAccountAndRegion": {
                "Type": "Task",
                "Resource": "${RestoreRDSInTargetAccountsAndRegionsLambdaArn}",
                "Next": "RestorePipelineComplete",
                "ResultPath": "$.output",
                "Retry": [{
                  "ErrorEquals": ["AutomationExecutionLimitExceededException"],
                  "IntervalSeconds": 10,
                  "MaxAttempts": 5,
                  "BackoffRate": 2.0
                 }],
                "Catch": [
                  {
                    "ErrorEquals": [ "States.ALL" ],
                    "Next": "FailedState"
                  }
                ]
              },
              "ShouldRestoreClusterOrInstance": {
                "Type": "Choice",
                  "Choices": [{
                    "Variable": "$.isCluster",
                    "BooleanEquals": false,
                    "Next": "ShouldTakeDbSnapshot"
                  }],
                  "Default": "ShouldTakeClusterSnapshot"
              },
              "ShouldTakeClusterSnapshot": {
                "Type": "Choice",
                  "Choices": [{
                    "Variable": "$.task",
                    "StringMatches": "create_snapshot*",
                    "Next": "ClusterSnapshotCreate"
                  }],
                  "Default": "ClusterRename"
              },
              "ClusterSnapshotCreate": {
                "Type": "Task",
                "Resource": "${ClusterSnapshotLambdaArn}",
                "Next": "GetClusterSnapshotStatus",
                "ResultPath": "$.output",
                "Retry": [{
                  "ErrorEquals": ["RateExceededException", "RetryClusterSnapshotException"],
                  "IntervalSeconds": 10,
                  "MaxAttempts": 5,
                  "BackoffRate": 2.0
                 }],
                "Catch": [
                  {
                    "ErrorEquals": [ "States.ALL" ],
                    "Next": "FailedState"
                  }
                ]
              },
              "GetClusterSnapshotStatus": {
                "Type": "Task",
                "Resource": "${ClusterStatusLambdaArn}",
                "Next": "IsClusterSnapshotAvailable",
                "Retry": [{
                  "ErrorEquals": ["InstanceUnavailableException"],
                  "IntervalSeconds": 5,
                  "MaxAttempts": 5,
                  "BackoffRate": 2.0
                 },
                 {
                  "ErrorEquals": ["RateExceededException"],
                  "IntervalSeconds": 10,
                  "MaxAttempts": 5,
                  "BackoffRate": 2.0
                 }],
                 "Catch": [
                  {
                    "ErrorEquals": [ "States.ALL" ],
                    "Next": "FailedState"
                  }
                ]
              },
              "IsClusterSnapshotAvailable": {
                "Type": "Choice",
                "Choices": [{
                  "Variable": "$.task",
                  "StringEquals": "TASK_COMPLETE",
                  "Next": "IsClusterUpdateSnapshotOnly"
                },
                {
                  "Variable": "$.task",
                  "StringEquals": "TASK_FAILED",
                  "Next": "FailedState"
                }],
                "Default": "GetClusterSnapshotStatus"
              },
              "IsClusterUpdateSnapshotOnly": {
                "Type": "Choice",
                "Choices": [{
                  "Variable": "$.taskname",
                  "StringEquals": "SnapshotCreationOnly",
                  "Next": "RestorePipelineComplete"
                },
                {
                  "Variable": "$.taskname",
                  "StringEquals": "SnapshotCreation",
                  "Next": "StartClusterSnapshotExportTask"
                }],
                "Default": "GetClusterSnapshotStatus"
              },
              "StartClusterSnapshotExportTask": {
                "Type": "Task",
                "Resource": "${ClusterSnapshotExportLambdaArn}",
                "Next": "ClusterRename",
                "ResultPath": "$.output",
                "Retry": [{
                  "ErrorEquals": ["Exception", "States.TaskFailed"],
                  "IntervalSeconds": 10,
                  "MaxAttempts": 5,
                  "BackoffRate": 2.0
                 }],
                "Catch": [
                  {
                    "ErrorEquals": [ "States.ALL" ],
                    "Next": "FailedState"
                  }
                ]
              },
              "ClusterRename": {
                "Type": "Task",
                "Resource": "${ClusterRenameLambdaArn}",
                "Next": "GetClusterStatusPostRename",
                "ResultPath": "$.output",
                "Retry": [{
                  "ErrorEquals": ["RateExceededException"],
                  "IntervalSeconds": 10,
                  "MaxAttempts": 5,
                  "BackoffRate": 2.0
                 }],
                "Catch": [
                  {
                    "ErrorEquals": [ "States.ALL" ],
                    "Next": "FailedState"
                  }
                ]
              },
              "GetClusterStatusPostRename": {
                "Type": "Task",
                "Resource": "${ClusterStatusLambdaArn}",
                "Next": "IsClusterAvailablePostRename",
                "Retry": [{
                  "ErrorEquals": ["InstanceUnavailableException"],
                  "IntervalSeconds": 5,
                  "MaxAttempts": 5,
                  "BackoffRate": 2.0
                 },
                 {
                  "ErrorEquals": ["RateExceededException"],
                  "IntervalSeconds": 10,
                  "MaxAttempts": 5,
                  "BackoffRate": 2.0
                 }],
                 "Catch": [
                  {
                    "ErrorEquals": [ "States.ALL" ],
                    "Next": "FailedState"
                  }
                ]
              },
              "IsClusterAvailablePostRename": {
                "Type": "Choice",
                "Choices": [{
                  "Variable": "$.task",
                  "StringEquals": "TASK_COMPLETE",
                  "Next": "RestoreClusterFromSnapshot"
                },
                {
                  "Variable": "$.task",
                  "StringEquals": "TASK_FAILED",
                  "Next": "FailedState"
                }],
                "Default": "GetClusterStatusPostRestore"
              },
              "RestoreClusterFromSnapshot": {
                "Type": "Task",
                "Resource": "${ClusterRestoreLambdaArn}",
                "ResultPath": "$.output",
                "Next": "GetClusterStatusPostRestore",
                "Retry": [{
                  "ErrorEquals": ["RateExceededException"],
                  "IntervalSeconds": 10,
                  "MaxAttempts": 5,
                  "BackoffRate": 2.0
                }],
                "Catch": [
                  {
                    "ErrorEquals": [ "States.ALL" ],
                    "Next": "FailedState"
                  }
                ]
              },
              "GetClusterStatusPostRestore": {
                "Type": "Task",
                "Resource": "${ClusterStatusLambdaArn}",
                "Next": "IsClusterAvailablePostRestore",
                "Retry": [{
                  "ErrorEquals": ["InstanceUnavailableException"],
                  "IntervalSeconds": 5,
                  "MaxAttempts": 5,
                  "BackoffRate": 2.0
                 },
                 {
                  "ErrorEquals": ["RateExceededException", "Lambda.Unknown"],
                  "IntervalSeconds": 10,
                  "MaxAttempts": 5,
                  "BackoffRate": 2.0
                 }],
                 "Catch": [
                  {
                    "ErrorEquals": [ "States.ALL" ],
                    "Next": "FailedState"
                  }
                ]
              },
              "IsClusterAvailablePostRestore": {
                "Type": "Choice",
                "Choices": [{
                  "Variable": "$.task",
                  "StringEquals": "TASK_COMPLETE",
                  "Next": "DeleteOriginalCluster"
                },
                {
                  "Variable": "$.task",
                  "StringEquals": "TASK_FAILED",
                  "Next": "FailedState"
                }],
                "Default": "GetClusterStatusPostRestore"
              },
              "DeleteOriginalCluster": {
                "Type": "Task",
                "Resource": "${ClusterDeleteLambdaArn}",
                "ResultPath": "$.output",
                "Next": "GetClusterStatusPostDelete",
                "Retry": [{
                  "ErrorEquals": ["RateExceededException"],
                  "IntervalSeconds": 10,
                  "MaxAttempts": 5,
                  "BackoffRate": 2.0
                 }],
                "Catch": [
                  {
                    "ErrorEquals": [ "States.ALL" ],
                    "Next": "FailedState"
                  }
                ]
              },
              "GetClusterStatusPostDelete": {
                "Type": "Task",
                "Resource": "${ClusterStatusLambdaArn}",
                "Next": "isClusterDeleted",
                "Retry": [{
                  "ErrorEquals": ["RateExceededException"],
                  "IntervalSeconds": 10,
                  "MaxAttempts": 5,
                  "BackoffRate": 2.0
                }],
                "Catch": [
                  {
                    "ErrorEquals": [ "States.ALL" ],
                    "Next": "FailedState"
                  }
                ]
              },
              "isClusterDeleted": {
                "Type": "Choice",
                "Choices": [{
                  "Variable": "$.task",
                  "StringEquals": "TASK_COMPLETE",
                  "Next": "RestorePipelineComplete"
                },
                {
                  "Variable": "$.task",
                  "StringEquals": "TASK_FAILED",
                  "Next": "FailedState"
                }],
                "Default": "GetClusterStatusPostDelete"
              },
              "ShouldTakeDbSnapshot": {
                "Type": "Choice",
                "Choices": [{
                  "Variable": "$.task",
                  "StringMatches": "create_snapshot*",
                  "Next": "DbSnapshotCreate"
                }],
                "Default": "DbInstanceRename"
              },
              "DbSnapshotCreate": {
                "Type": "Task",
                "Resource": "${DBSnapshotLambdaArn}",
                "Next": "GetDbSnapshotStatus",
                "ResultPath": "$.output",
                "Retry": [{
                  "ErrorEquals": ["RateExceededException", "RetryDBSnapshotException"],
                  "IntervalSeconds": 10,
                  "MaxAttempts": 5,
                  "BackoffRate": 2.0
                 }],
                "Catch": [
                  {
                    "ErrorEquals": [ "States.ALL" ],
                    "Next": "FailedState"
                  }
                ]
              },
              "GetDbSnapshotStatus": {
                "Type": "Task",
                "Resource": "${DBStatusLambdaArn}",
                "Next": "IsDbSnapshotAvailable",
                "Retry": [{
                  "ErrorEquals": ["InstanceUnavailableException"],
                  "IntervalSeconds": 5,
                  "MaxAttempts": 5,
                  "BackoffRate": 2.0
                 },
                 {
                  "ErrorEquals": ["RateExceededException"],
                  "IntervalSeconds": 10,
                  "MaxAttempts": 5,
                  "BackoffRate": 2.0
                 }],
                 "Catch": [
                  {
                    "ErrorEquals": [ "States.ALL" ],
                    "Next": "FailedState"
                  }
                ]
              },
              "IsDbSnapshotAvailable": {
                "Type": "Choice",
                "Choices": [{
                  "Variable": "$.task",
                  "StringEquals": "TASK_COMPLETE",
                  "Next": "IsDbUpdateSnapshotOnly"
                },
                {
                  "Variable": "$.task",
                  "StringEquals": "TASK_FAILED",
                  "Next": "FailedState"
                }],
                "Default": "GetDbSnapshotStatus"
              },
              "IsDbUpdateSnapshotOnly": {
                "Type": "Choice",
                "Choices": [{
                  "Variable": "$.taskname",
                  "StringEquals": "SnapshotCreationOnly",
                  "Next": "RestorePipelineComplete"
                },
                {
                  "Variable": "$.taskname",
                  "StringEquals": "SnapshotCreation",
                  "Next": "StartSnapshotExportTask"
                }],
                "Default": "GetDbSnapshotStatus"
              },
              "StartSnapshotExportTask": {
                "Type": "Task",
                "Resource": "${DBSnapshotExportLambdaArn}",
                "Next": "DbInstanceRename",
                "ResultPath": "$.output",
                "Retry": [{
                  "ErrorEquals": ["Exception", "States.TaskFailed"],
                  "IntervalSeconds": 10,
                  "MaxAttempts": 5,
                  "BackoffRate": 2.0
                 }],
                "Catch": [
                  {
                    "ErrorEquals": [ "States.ALL" ],
                    "Next": "FailedState"
                  }
                ]
              },
              "DbInstanceRename": {
                "Type": "Task",
                "Resource": "${DBRenameLambdaArn}",
                "Next": "GetDbInstanceStatusPostRename",
                "ResultPath": "$.output",
                "Retry": [{
                  "ErrorEquals": ["RateExceededException"],
                  "IntervalSeconds": 10,
                  "MaxAttempts": 5,
                  "BackoffRate": 2.0
                 }],
                "Catch": [
                  {
                    "ErrorEquals": [ "States.ALL" ],
                    "Next": "FailedState"
                  }
                ]
              },
              "GetDbInstanceStatusPostRename": {
                "Type": "Task",
                "Resource": "${DBStatusLambdaArn}",
                "Next": "IsDbInstanceAvailablePostRename",
                "Retry": [{
                  "ErrorEquals": ["InstanceUnavailableException"],
                  "IntervalSeconds": 5,
                  "MaxAttempts": 5,
                  "BackoffRate": 2.0
                 },
                 {
                  "ErrorEquals": ["RateExceededException"],
                  "IntervalSeconds": 10,
                  "MaxAttempts": 5,
                  "BackoffRate": 2.0
                 }],
                 "Catch": [
                  {
                    "ErrorEquals": [ "States.ALL" ],
                    "Next": "FailedState"
                  }
                ]
              },
              "IsDbInstanceAvailablePostRename": {
                "Type": "Choice",
                "Choices": [{
                  "Variable": "$.task",
                  "StringEquals": "TASK_COMPLETE",
                  "Next": "RestoreDbInstanceFromSnapshot"
                },
                {
                  "Variable": "$.task",
                  "StringEquals": "TASK_FAILED",
                  "Next": "FailedState"
                }],
                "Default": "GetDbInstanceStatusPostRename"
              },
              "RestoreDbInstanceFromSnapshot": {
                "Type": "Task",
                "Resource": "${DBRestoreLambdaArn}",
                "ResultPath": "$.output",
                "Next": "GetDbInstanceStatusPostRestore",
                 "Retry": [{
                  "ErrorEquals": ["RateExceededException"],
                  "IntervalSeconds": 10,
                  "MaxAttempts": 5,
                  "BackoffRate": 2.0
                 }],
                "Catch": [
                  {
                    "ErrorEquals": [ "States.ALL" ],
                    "Next": "FailedState"
                  }
                ]
              },
              "GetDbInstanceStatusPostRestore": {
                "Type": "Task",
                "Resource": "${DBStatusLambdaArn}",
                "Next": "IsDbInstanceAvailablePostRestore",
                "Retry": [{
                  "ErrorEquals": ["InstanceUnavailableException"],
                  "IntervalSeconds": 5,
                  "MaxAttempts": 5,
                  "BackoffRate": 2.0
                 },
                 {
                  "ErrorEquals": ["RateExceededException", "Lambda.Unknown"],
                  "IntervalSeconds": 10,
                  "MaxAttempts": 5,
                  "BackoffRate": 2.0
                 }],
                 "Catch": [
                  {
                    "ErrorEquals": [ "States.ALL" ],
                    "Next": "FailedState"
                  }
                ]
              },
              "IsDbInstanceAvailablePostRestore": {
                "Type": "Choice",
                "Choices": [{
                  "Variable": "$.task",
                  "StringEquals": "TASK_COMPLETE",
                  "Next": "DeleteOriginalDbInstance"
                },
                {
                  "Variable": "$.task",
                  "StringEquals": "TASK_FAILED",
                  "Next": "FailedState"
                }],
                "Default": "GetDbInstanceStatusPostRestore"
              },
              "DeleteOriginalDbInstance": {
                "Type": "Task",
                "Resource": "${DBDeleteLambdaArn}",
                "ResultPath": "$.output",
                "Next": "GetDbInstanceStatusPostDelete",
                "Retry": [{
                  "ErrorEquals": ["RateExceededException"],
                  "IntervalSeconds": 10,
                  "MaxAttempts": 5,
                  "BackoffRate": 2.0
                 }],
                "Catch": [
                  {
                    "ErrorEquals": [ "States.ALL" ],
                    "Next": "FailedState"
                  }
                ]
              },
              "GetDbInstanceStatusPostDelete": {
                "Type": "Task",
                "Resource": "${DBStatusLambdaArn}",
                "Next": "isDbInstanceDeleted",
                "Retry": [{
                  "ErrorEquals": ["RateExceededException"],
                  "IntervalSeconds": 10,
                  "MaxAttempts": 5,
                  "BackoffRate": 2.0
                }],
                "Catch": [
                  {
                    "ErrorEquals": [ "States.ALL" ],
                    "Next": "FailedState"
                  }
                ]
              },
              "isDbInstanceDeleted": {
                "Type": "Choice",
                "Choices": [{
                  "Variable": "$.task",
                  "StringEquals": "TASK_COMPLETE",
                  "Next": "RestorePipelineComplete"
                },
                {
                  "Variable": "$.task",
                  "StringEquals": "TASK_FAILED",
                  "Next": "FailedState"
                }],
                "Default": "GetDbInstanceStatusPostDelete"
              },
              "FailedState": {
                "Type": "Parallel",
                "Next": "RestorePipelineComplete",
                "Branches": [
                  {
                   "StartAt": "SendFailureAlert",
                   "States": {
                     "SendFailureAlert": {
                       "Type": "Task",
                       "Resource": "${EmailAlertLambdaArn}",
                       "Next": "SendSlackFailureAlert"
                     },
                     "SendSlackFailureAlert": {
                       "Type": "Task",
                       "Resource": "${SlackAlertLambdaArn}",
                       "End": true
                     }
                   }
                 },
                 {
                   "StartAt": "CheckForRenameReversal",
                   "States": {
                     "CheckForRenameReversal": {
                       "Type": "Choice",
                       "Choices": [
                          {
                              "Variable": "$.Error",
                              "StringEquals": "InstanceRestoreException",
                              "Next": "RevertOldInstanceRename"
                          },
                          {
                              "Variable": "$.Error",
                              "StringEquals": "ClusterRestoreException",
                              "Next": "RevertOldClusterRename"
                          }
                       ],
                       "Default": "NoRollback"
                     },
                     "RevertOldInstanceRename": {
                       "Type": "Task",
                       "Resource": "${DBRenameLambdaArn}",
                       "Next": "GetDbInstanceStatusPostRenameRevert",
                       "ResultPath": "$.output",
                       "Retry": [{
                                   "ErrorEquals": [
                                     "RateExceededException"
                                   ],
                                   "IntervalSeconds": 10,
                                   "MaxAttempts": 5,
                                   "BackoffRate": 2
                                 }],
                       "Catch": [{
                                   "ErrorEquals": [
                                     "States.ALL"
                                   ],
                                   "Next": "SendRollbackFailureAlert"
                                 }]
                     },
                     "RevertOldClusterRename": {
                       "Type": "Task",
                       "Resource": "${ClusterRenameLambdaArn}",
                       "Next": "GetClusterStatusPostRenameRevert",
                       "ResultPath": "$.output",
                       "Retry": [{
                                   "ErrorEquals": [
                                     "RateExceededException"
                                   ],
                                   "IntervalSeconds": 10,
                                   "MaxAttempts": 5,
                                   "BackoffRate": 2
                                 }],
                       "Catch": [{
                                   "ErrorEquals": [
                                     "States.ALL"
                                   ],
                                   "Next": "SendRollbackFailureAlert"
                                 }]
                     },
                     "GetDbInstanceStatusPostRenameRevert": {
                       "Type": "Task",
                       "Resource": "${DBStatusLambdaArn}",
                       "End": true,
                       "Retry": [{
                                   "ErrorEquals": [
                                     "InstanceUnavailableException"
                                   ],
                                   "IntervalSeconds": 5,
                                   "MaxAttempts": 5,
                                   "BackoffRate": 2
                                 },
                                 {
                                   "ErrorEquals": [
                                     "RateExceededException"
                                   ],
                                   "IntervalSeconds": 10,
                                   "MaxAttempts": 5,
                                   "BackoffRate": 2
                                 }],
                       "Catch": [{
                                   "ErrorEquals": [
                                     "States.ALL"
                                   ],
                                   "Next": "SendRollbackFailureAlert"
                                 }]
                     },
                     "GetClusterStatusPostRenameRevert": {
                       "Type": "Task",
                       "Resource": "${ClusterStatusLambdaArn}",
                       "End": true,
                       "Retry": [{
                                   "ErrorEquals": [
                                     "InstanceUnavailableException"
                                   ],
                                   "IntervalSeconds": 5,
                                   "MaxAttempts": 5,
                                   "BackoffRate": 2
                                 },
                                 {
                                   "ErrorEquals": [
                                     "RateExceededException"
                                   ],
                                   "IntervalSeconds": 10,
                                   "MaxAttempts": 5,
                                   "BackoffRate": 2
                                 }],
                       "Catch": [{
                                   "ErrorEquals": [
                                     "States.ALL"
                                   ],
                                   "Next": "SendRollbackFailureAlert"
                                 }]
                     },
                     "SendRollbackFailureAlert": {
                       "Type": "Task",
                       "Resource": "${EmailAlertLambdaArn}",
                       "Next": "SendSlackRollbackFailureAlert"
                     },
                     "SendSlackRollbackFailureAlert": {
                       "Type": "Task",
                       "Resource": "${SlackAlertLambdaArn}",
                       "End": true
                     },
                     "NoRollback": {
                       "Type": "Pass",
                       "End": true
                     }
                   }
                 }
                ]
              },
              "RestorePipelineComplete": {
                 "Type": "Pass",
                 "End": true
              }
            }
          }
        - {
            ClusterRenameLambdaArn: !GetAtt ClusterRenameLambdaFunction.Arn,
            ClusterStatusLambdaArn: !GetAtt ClusterStatusLambdaFunction.Arn,
            ClusterSnapshotLambdaArn: !GetAtt ClusterSnapshotLambdaFunction.Arn,
            ClusterRestoreLambdaArn: !GetAtt ClusterRestoreLambdaFunction.Arn,
            ClusterDeleteLambdaArn: !GetAtt ClusterDeleteLambdaFunction.Arn,
            ClusterSnapshotExportLambdaArn: !GetAtt ClusterSnapshotExportLambdaFunction.Arn,
            DBRenameLambdaArn: !GetAtt RenameLambdaFunction.Arn,
            DBStatusLambdaArn: !GetAtt DbInstanceStatusLambdaFunction.Arn,
            DBSnapshotLambdaArn: !GetAtt DBSnapshotLambdaFunction.Arn,
            DBRestoreLambdaArn: !GetAtt DBRestoreLambdaFunction.Arn,
            DBDeleteLambdaArn: !GetAtt DeleteInstanceLambdaFunction.Arn,
            DBSnapshotExportLambdaArn: !GetAtt SnapshotExportLambdaFunction.Arn,
            EmailAlertLambdaArn: !GetAtt EmailAlertLambdaFunction.Arn,
            SlackAlertLambdaArn: !GetAtt SlackAlertLambdaFunction.Arn,
            ShareSnapshotLambdaArn: !GetAtt ShareSnapshotLambdaFunction.Arn,
            RestoreRDSInTargetAccountsAndRegionsLambdaArn: !GetAtt RestoreRDSInTargetAccountsAndRegionsLambdaFunction.Arn
          }
      RoleArn: !GetAtt StatesExecutionRole.Arn
      Tags:
        - Key: "AppComponent"
          Value: "trapheus:StepFunction"
        - Key: "AppFunction"
          Value: "trapheus:DBRestoreStateMachine"

  DBRestoreStateMachineEventRule:
    Type: AWS::Events::Rule
    Properties:
      Description: Trigger the DBRestoreStateMachine
      Name: !Sub ${ProjectName}-DBRestoreStateMachine-rule
      ScheduleExpression: "cron(0 8 ? * FRI *)" # Runs every FRIDAY at 8:00 AM UTC
      State:  DISABLED # Change value to ENABLED to enable the scheduled rule
      Targets:
        - Arn: !GetAtt DBRestoreStateMachine.Arn
          RoleArn: !GetAtt CWEventStatesExecutionRole.Arn
          Id: !Sub ${ProjectName}-rds-identifier-X
          Input: '{
                      "identifier": "identifier-X",
                      "task": "create_snapshot",
                      "isCluster": false
                  }'
        - Arn: !GetAtt DBRestoreStateMachine.Arn
          RoleArn: !GetAtt CWEventStatesExecutionRole.Arn
          Id: !Sub ${ProjectName}-rds-identifier-Y
          Input: '{
                      "identifier": "identifier-Y",
                      "task": "create_snapshot",
                      "isCluster": true
                  }'

